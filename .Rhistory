xml2::xml_find_all("//blockquote|//h1/*") |>
purrr::map2(xml2::xml_name(.), ~tryCatch({
if (chatty){ message(.y) }
list(
tag = xml2::xml_name(.x)
, # {.y == "a"} | "XPATH search above (xml_find_all(...)) returns the '<a>' as the first child of the search path "//blockquote.
vals = if(.y == "a"){
xml2::xml_attr(.x, "href") |>
stringi::stri_extract_first_regex("[0-9]+")
} else {
sapply(xml2::xml_children(.x), xml_text) |>
stringi::stri_enc_toascii() |>
stringi::stri_split_fixed("\n", simplify = FALSE) |>
purrr::reduce(rbind) |>
stringi::stri_trim_both() |>
stringi::stri_replace_first_regex("[-]", "")
}
)}
, error = function(e){ }
, finally = ""
))
})[
, # "Unwrap" the HTML markup structure, matching tags with the text
{ c(.SD[, !c("tag")]
, book.of.workflow::logic_map(.SD$tag)[, purrr::map(.SD, cumsum)]
, book.of.workflow::logic_map(vals, bvec = purrr::keep(vals, ~.x %like% "^[A-Z]{5,15}$") |> unique())
)}
][
, # +{notification_date, sub_group} | Date of log entry on page, indicator of the changeset across each date of entry
`:=`(notification_date = data.table::first(vals), sub_group = cumsum(vals %like% "^[A-Z]{5,9}$"))
, by = c("a")
][][
, c(
list(vals = vals)
, # @TRANSFORMATION{ ADDED, CHANGED, DEPRECATED, REMOVED, FIXED } | For each group defined in the 'by' expression, return the cumulative maximum: this maps each of the changes under "vals" to the correct type of change.  This allows unnecessary rows to be removed in subsequent steps.
purrr::map(.SD[, !c("vals", "blockquote")], ~cummax(.x))
)
, by = .(a, sub_group, notification_date)
][
# @FILTER | Remove rows that do not indicate a change type or where elements of 'vals' only have the change type (these are simply not needed at this point)
and(!vals %like% "[A-Z]{5,9}"
, data.table::data.table(ADDED, CHANGED, DEPRECATED, REMOVED, FIXED)|> purrr::map_lgl(function(...){ sum(c(...)) > 0 })
) |> which()
][, purrr::modify_at(.SD, ls(.SD, pattern = "[A-Z]{5,9}"), as.logical)
][, # +{eff_date} | When "schedule" is matched in 'vals', it is assumed a scheduled implementation date is given.  This code extracts that date if it exists or returns the log entry date if there is no match.
eff_date := {
ifelse(
vals %ilike% "schedule"
, stringi::stri_extract_all_regex(vals, "([0-9]+[.]?)+", simplify = TRUE) |>
stringi::stri_replace_all_fixed(".", "", vectorize_all = FALSE)
, notification_date
)
} |> as.Date(format = "%Y%m%d")
][, # +{schedule}  | Chronology indicator
schedule := (sign(lubridate::today() - eff_date)) |> as.character() %>% {
purrr::set_names(c("FUTURE", "TODAY", "PAST"), as.character(-1:1))[.]
}
][] |>
data.table::setnames(c(1:2, 4), c("change_set_id", "change_det_id", "change_note"))
}
# Set definition attributes for each column
ipurrr::walk(.dictionary, ~data.table::setattr(.changelog$explore[[.y]], "def", .x))
self$changelog <- .changelog;
invisible(self)
}
function(chatty = FALSE){
.dictionary = { c(
"Grouping ID at the level of the date of change"
, "Grouping ID at the level of the type of change"
, "The date of the entry"
, "The entry notes containing what was changed along with additional details"
, "A type of change" |> rep.int(5)
, "Either the date of entry or a future date (matches against 'schedule' and looks for a date in format \"([0-9]+[.]?)+\" "
, "One of \"PAST\" or \"FUTURE\" based on the value of column 'eff_date' relative to the current date "
)
} |>
rlang::set_names("change_set_id", "change_det_id"
, "notification_date", "change_note"
, "ADDED", "CHANGED", "DEPRECATED"
, "REMOVED", "FIXED"
, "eff_date", "schedule"
) |> as.list();
if (rlang::is_empty(private$keyring_credentials)){
message("No keyring credentials detected ...")
private$keyring_credentials <- list(
keyring = readline(prompt = "... enter keyring name or leave blank: ") %>% {
ifelse(stringi::stringi::stri_length(.) == 0, NULL, .) }
, service = readline(prompt = "... enter keyring service or leave blank: ") %>% {
ifelse(stringi::stringi::stri_length(.) == 0, NULL, .) }
, username = readline(prompt = "... enter keyring username or leave blank: ") %>% {
ifelse(stringi::stringi::stri_length(.) == 0, NULL, .) }
)
}
.changelog = list();
.changelog$content = query_adhoc(url = self$changelog_url, !!!private$keyring_credentials) |>
xml2::read_html() |> xml2::xml_children() |> data.table::last();
.changelog$explore = { # This entire code block navigates the structure of the retrieved page from the website
data.table::rbindlist({
.changelog$content |>
xml2::xml_find_all("//template[@slot='contents']") |>
xml2::xml_children() |>
xml2::xml_find_all("//blockquote|//h1/*") |>
purrr::map2(xml2::xml_name(.), ~tryCatch({
if (chatty){ message(.y) }
list(
tag = xml2::xml_name(.x)
, # {.y == "a"} | "XPATH search above (xml_find_all(...)) returns the '<a>' as the first child of the search path "//blockquote.
vals = if(.y == "a"){
xml2::xml_attr(.x, "href") |>
stringi::stri_extract_first_regex("[0-9]+")
} else {
sapply(xml2::xml_children(.x), xml_text) |>
stringi::stri_enc_toascii() |>
stringi::stri_split_fixed("\n", simplify = FALSE) |>
purrr::reduce(rbind) |>
stringi::stri_trim_both() |>
stringi::stri_replace_first_regex("[-]", "")
}
)}
, error = function(e){ }
, finally = ""
))
})[
, # "Unwrap" the HTML markup structure, matching tags with the text
{ c(.SD[, !c("tag")]
, book.of.workflow::logic_map(.SD$tag)[, purrr::map(.SD, cumsum)]
, book.of.workflow::logic_map(vals, bvec = purrr::keep(vals, ~.x %like% "^[A-Z]{5,15}$") |> unique())
)}
][
, # +{notification_date, sub_group} | Date of log entry on page, indicator of the changeset across each date of entry
`:=`(notification_date = data.table::first(vals), sub_group = cumsum(vals %like% "^[A-Z]{5,9}$"))
, by = c("a")
][][
, c(
list(vals = vals)
, # @TRANSFORMATION{ ADDED, CHANGED, DEPRECATED, REMOVED, FIXED } | For each group defined in the 'by' expression, return the cumulative maximum: this maps each of the changes under "vals" to the correct type of change.  This allows unnecessary rows to be removed in subsequent steps.
purrr::map(.SD[, !c("vals", "blockquote")], ~cummax(.x))
)
, by = .(a, sub_group, notification_date)
][
# @FILTER | Remove rows that do not indicate a change type or where elements of 'vals' only have the change type (these are simply not needed at this point)
and(!vals %like% "[A-Z]{5,9}"
, data.table::data.table(ADDED, CHANGED, DEPRECATED, REMOVED, FIXED)|> purrr::map_lgl(function(...){ sum(c(...)) > 0 })
) |> which()
][, purrr::modify_at(.SD, ls(.SD, pattern = "[A-Z]{5,9}"), as.logical)
][, # +{eff_date} | When "schedule" is matched in 'vals', it is assumed a scheduled implementation date is given.  This code extracts that date if it exists or returns the log entry date if there is no match.
eff_date := {
ifelse(
vals %ilike% "schedule"
, stringi::stri_extract_all_regex(vals, "([0-9]+[.]?)+", simplify = TRUE) |>
stringi::stri_replace_all_fixed(".", "", vectorize_all = FALSE)
, notification_date
)
} |> as.Date(format = "%Y%m%d")
][, # +{schedule}  | Chronology indicator
schedule := (sign(lubridate::today() - eff_date)) |> as.character() %>% {
purrr::set_names(c("FUTURE", "TODAY", "PAST"), as.character(-1:1))[.]
}
][] |>
data.table::setnames(c(1:2, 4), c("change_set_id", "change_det_id", "change_note"))
}
# Set definition attributes for each column
ipurrr::walk(.dictionary, ~data.table::setattr(.changelog$explore[[.y]], "def", .x))
self$changelog <- .changelog;
invisible(self)
}
function(chatty = FALSE){
.dictionary = { c(
"Grouping ID at the level of the date of change"
, "Grouping ID at the level of the type of change"
, "The date of the entry"
, "The entry notes containing what was changed along with additional details"
, "A type of change" |> rep.int(5)
, "Either the date of entry or a future date (matches against 'schedule' and looks for a date in format \"([0-9]+[.]?)+\" "
, "One of \"PAST\" or \"FUTURE\" based on the value of column 'eff_date' relative to the current date "
)
} |>
rlang::set_names("change_set_id", "change_det_id"
, "notification_date", "change_note"
, "ADDED", "CHANGED", "DEPRECATED"
, "REMOVED", "FIXED"
, "eff_date", "schedule"
) |> as.list();
if (rlang::is_empty(private$keyring_credentials)){
message("No keyring credentials detected ...")
private$keyring_credentials <- list(
keyring = readline(prompt = "... enter keyring name or leave blank: ") %>% {
ifelse(stringi::stringi::stri_length(.) == 0, NULL, .) }
, service = readline(prompt = "... enter keyring service or leave blank: ") %>% {
ifelse(stringi::stringi::stri_length(.) == 0, NULL, .) }
, username = readline(prompt = "... enter keyring username or leave blank: ") %>% {
ifelse(stringi::stringi::stri_length(.) == 0, NULL, .) }
)
}
.changelog = list();
.changelog$content = query_adhoc(url = self$changelog_url, !!!private$keyring_credentials) |>
xml2::read_html() |> xml2::xml_children() |> data.table::last();
.changelog$explore = { # This entire code block navigates the structure of the retrieved page from the website
data.table::rbindlist({
.changelog$content |>
xml2::xml_find_all("//template[@slot='contents']") |>
xml2::xml_children() |>
xml2::xml_find_all("//blockquote|//h1/*") |>
purrr::map2(xml2::xml_name(.), ~tryCatch({
if (chatty){ message(.y) }
list(
tag = xml2::xml_name(.x)
, # {.y == "a"} | "XPATH search above (xml_find_all(...)) returns the '<a>' as the first child of the search path "//blockquote.
vals = if(.y == "a"){
xml2::xml_attr(.x, "href") |>
stringi::stri_extract_first_regex("[0-9]+")
} else {
sapply(xml2::xml_children(.x), xml_text) |>
stringi::stri_enc_toascii() |>
stringi::stri_split_fixed("\n", simplify = FALSE) |>
purrr::reduce(rbind) |>
stringi::stri_trim_both() |>
stringi::stri_replace_first_regex("[-]", "")
}
)}
, error = function(e){ }
, finally = ""
))
})[
, # "Unwrap" the HTML markup structure, matching tags with the text
{ c(.SD[, !c("tag")]
, book.of.workflow::logic_map(.SD$tag)[, purrr::map(.SD, cumsum)]
, book.of.workflow::logic_map(vals, bvec = purrr::keep(vals, ~.x %like% "^[A-Z]{5,15}$") |> unique())
)}
][
, # +{notification_date, sub_group} | Date of log entry on page, indicator of the changeset across each date of entry
`:=`(notification_date = data.table::first(vals), sub_group = cumsum(vals %like% "^[A-Z]{5,9}$"))
, by = c("a")
][][
, c(
list(vals = vals)
, # @TRANSFORMATION{ ADDED, CHANGED, DEPRECATED, REMOVED, FIXED } | For each group defined in the 'by' expression, return the cumulative maximum: this maps each of the changes under "vals" to the correct type of change.  This allows unnecessary rows to be removed in subsequent steps.
purrr::map(.SD[, !c("vals", "blockquote")], ~cummax(.x))
)
, by = .(a, sub_group, notification_date)
][
# @FILTER | Remove rows that do not indicate a change type or where elements of 'vals' only have the change type (these are simply not needed at this point)
and(!vals %like% "[A-Z]{5,9}"
, data.table::data.table(ADDED, CHANGED, DEPRECATED, REMOVED, FIXED)|> purrr::map_lgl(function(...){ sum(c(...)) > 0 })
) |> which()
][, purrr::modify_at(.SD, ls(.SD, pattern = "[A-Z]{5,9}"), as.logical)
][, # +{eff_date} | When "schedule" is matched in 'vals', it is assumed a scheduled implementation date is given.  This code extracts that date if it exists or returns the log entry date if there is no match.
eff_date := {
ifelse(
vals %ilike% "schedule"
, stringi::stri_extract_all_regex(vals, "([0-9]+[.]?)+", simplify = TRUE) |>
stringi::stri_replace_all_fixed(".", "", vectorize_all = FALSE)
, notification_date
)
} |> as.Date(format = "%Y%m%d")
][, # +{schedule}  | Chronology indicator
schedule := (sign(lubridate::today() - eff_date)) |> as.character() %>% {
purrr::set_names(c("FUTURE", "TODAY", "PAST"), as.character(-1:1))[.]
}
][] |>
data.table::setnames(c(1:2, 4), c("change_set_id", "change_det_id", "change_note"))
}
# Set definition attributes for each column
ipurrr::walk(.dictionary, ~data.table::setattr(.changelog$explore[[.y]], "def", .x))
self$changelog <- .changelog;
invisible(self)
}
function(chatty = FALSE){
.dictionary = { c(
"Grouping ID at the level of the date of change"
, "Grouping ID at the level of the type of change"
, "The date of the entry"
, "The entry notes containing what was changed along with additional details"
, "A type of change" |> rep.int(5)
, "Either the date of entry or a future date (matches against 'schedule' and looks for a date in format \"([0-9]+[.]?)+\" "
, "One of \"PAST\" or \"FUTURE\" based on the value of column 'eff_date' relative to the current date "
)
} |>
rlang::set_names("change_set_id", "change_det_id"
, "notification_date", "change_note"
, "ADDED", "CHANGED", "DEPRECATED"
, "REMOVED", "FIXED"
, "eff_date", "schedule"
) |> as.list();
if (rlang::is_empty(private$keyring_credentials)){
message("No keyring credentials detected ...")
private$keyring_credentials <- list(
keyring = readline(prompt = "... enter keyring name or leave blank: ") %>% {
ifelse(stringi::stri_length(.) == 0, NULL, .) }
, service = readline(prompt = "... enter keyring service or leave blank: ") %>% {
ifelse(stringi::stri_length(.) == 0, NULL, .) }
, username = readline(prompt = "... enter keyring username or leave blank: ") %>% {
ifelse(stringi::stri_length(.) == 0, NULL, .) }
)
}
.changelog = list();
.changelog$content = query_adhoc(url = self$changelog_url, !!!private$keyring_credentials) |>
xml2::read_html() |> xml2::xml_children() |> data.table::last();
.changelog$explore = { # This entire code block navigates the structure of the retrieved page from the website
data.table::rbindlist({
.changelog$content |>
xml2::xml_find_all("//template[@slot='contents']") |>
xml2::xml_children() |>
xml2::xml_find_all("//blockquote|//h1/*") |>
purrr::map2(xml2::xml_name(.), ~tryCatch({
if (chatty){ message(.y) }
list(
tag = xml2::xml_name(.x)
, # {.y == "a"} | "XPATH search above (xml_find_all(...)) returns the '<a>' as the first child of the search path "//blockquote.
vals = if(.y == "a"){
xml2::xml_attr(.x, "href") |>
stringi::stri_extract_first_regex("[0-9]+")
} else {
sapply(xml2::xml_children(.x), xml_text) |>
stringi::stri_enc_toascii() |>
stringi::stri_split_fixed("\n", simplify = FALSE) |>
purrr::reduce(rbind) |>
stringi::stri_trim_both() |>
stringi::stri_replace_first_regex("[-]", "")
}
)}
, error = function(e){ }
, finally = ""
))
})[
, # "Unwrap" the HTML markup structure, matching tags with the text
{ c(.SD[, !c("tag")]
, book.of.workflow::logic_map(.SD$tag)[, purrr::map(.SD, cumsum)]
, book.of.workflow::logic_map(vals, bvec = purrr::keep(vals, ~.x %like% "^[A-Z]{5,15}$") |> unique())
)}
][
, # +{notification_date, sub_group} | Date of log entry on page, indicator of the changeset across each date of entry
`:=`(notification_date = data.table::first(vals), sub_group = cumsum(vals %like% "^[A-Z]{5,9}$"))
, by = c("a")
][][
, c(
list(vals = vals)
, # @TRANSFORMATION{ ADDED, CHANGED, DEPRECATED, REMOVED, FIXED } | For each group defined in the 'by' expression, return the cumulative maximum: this maps each of the changes under "vals" to the correct type of change.  This allows unnecessary rows to be removed in subsequent steps.
purrr::map(.SD[, !c("vals", "blockquote")], ~cummax(.x))
)
, by = .(a, sub_group, notification_date)
][
# @FILTER | Remove rows that do not indicate a change type or where elements of 'vals' only have the change type (these are simply not needed at this point)
and(!vals %like% "[A-Z]{5,9}"
, data.table::data.table(ADDED, CHANGED, DEPRECATED, REMOVED, FIXED)|> purrr::map_lgl(function(...){ sum(c(...)) > 0 })
) |> which()
][, purrr::modify_at(.SD, ls(.SD, pattern = "[A-Z]{5,9}"), as.logical)
][, # +{eff_date} | When "schedule" is matched in 'vals', it is assumed a scheduled implementation date is given.  This code extracts that date if it exists or returns the log entry date if there is no match.
eff_date := {
ifelse(
vals %ilike% "schedule"
, stringi::stri_extract_all_regex(vals, "([0-9]+[.]?)+", simplify = TRUE) |>
stringi::stri_replace_all_fixed(".", "", vectorize_all = FALSE)
, notification_date
)
} |> as.Date(format = "%Y%m%d")
][, # +{schedule}  | Chronology indicator
schedule := (sign(lubridate::today() - eff_date)) |> as.character() %>% {
purrr::set_names(c("FUTURE", "TODAY", "PAST"), as.character(-1:1))[.]
}
][] |>
data.table::setnames(c(1:2, 4), c("change_set_id", "change_det_id", "change_note"))
}
# Set definition attributes for each column
ipurrr::walk(.dictionary, ~data.table::setattr(.changelog$explore[[.y]], "def", .x))
self$changelog <- .changelog;
invisible(self)
}
function(db, ..., retain = TRUE){
# Create the output ====
output = dplyr::filter(.data = data.table::copy(self$changelog$explore), ...)[
, self[[db]]$metamap[!is.na(tbl_name)
, list(
change_obj = purrr::keep(tbl_name %>% unique, ~change_note %ilike% .x) |> list() |>
purrr::modify_if(~identical(character(0), .x), ~"<Removed/Missing>")
, ADDED, CHANGED, DEPRECATED, REMOVED, FIXED
)
]
, by = .(notification_date, change_note, schedule, eff_date)
];
# Return the output depending on the class of argument 'retain' ====
switch(
class(retain)
, "logical" = if (retain){
if (!"search.history" %in% ls(envir = self)){ self$search.history <- new.env() }
assign("search_" %s+% format(Sys.time(), "%Y.%m.%d_%H.%M.%S"), output, envir = self$search.history);
invisible(self);
} else { print(output); invisible(self) }
, "character" = {
if (!"search.history" %in% ls(envir = self)){ self$search.history <- new.env() }
assign(paste0(retain, "_", format(Sys.time(), "%Y.%m.%d_%H.%M.%S")), output, envir = self$search.history);
invisible(self);
}
, invisible(self)
);
}
function(code_files, use.search, retain = TRUE, chatty = FALSE, ...){
.us = NULL;
if (missing(use.search)){ use.search <- self$changelog } else
if ("choose" %ilike% use.search){
use.search <- tcltk::tk_select.list(
choices = ls(self$search.history)
, preselect = ls(self$search.history)[1]
, title = "Choose a previously made search"
, multiple = FALSE
) %T>% { .us <<- . } |>
get(envir = self$search.history)
} else {
use.search <- use.search %T>% { .us <<- . } |> get(envir = self$search.history)
}
code_files %<>% purrr::set_names(
stringi::stri_replace_all_fixed(., "\\", "/", vectorize_all = FALSE) %>%
stringi::stri_replace_all_regex("[:]+", "", vectorize_all = FALSE)
);
if (chatty){ message(length(code_files) %s+% " objects provided ...") }
code_files_content = purrr::imap_dfr(code_files, ~{
list(file = .y, text = stringi::stri_read_lines(.x) %>% paste(collapse = " "))
})|>
data.table::setDT();
.needle = use.search$change_obj |>
purrr::reduce(c) %>%
purrr::discard(~.x %like% "Missing") |>
rlang::list2(...) |>
unlist() |>
unique() %T>% { if (or(length(.) == 0, identical(character(0), .))){ message("No matches found: exiting ..."); return(0) }}
if (chatty){ print(.us); print(code_files_content) }
output = (code_files_content %look.for% paste(unlist(.needle), collapse = "|"));
if (!all(purrr::map_lgl(output, ~identical(character(), .x)))){
# Return the output depending on the class of argument 'retain' ====
switch(
class(retain)
, "logical" = if (retain){
if (!"code_xref.history" %in% ls(envir = self)){ self$code_xref.history <- new.env() }
assign(
paste0(c("xref_", .us %s+% "_")[1 + !is.null(.us)], format(Sys.time(), "%Y.%m.%d_%H.%M.%S"))
, output
, envir = self$code_xref.history
);
invisible(self);
} else { print(output); invisible(self) }
, "character" = {
if (!"code_xref.history" %in% ls(envir = self)){ self$code_xref.history <- new.env() }
assign(
paste0(retain, "_", format(Sys.time(), "%Y.%m.%d_%H.%M.%S"))
, output[, related_search := .us]
, envir = self$code_xref.history
);
invisible(self);
}
, invisible(self)
);
} else { invisible(self)}
}
function(conn_name = names(self$conns), db_env = new.env(), ...){
db <- match.arg(conn_name);
obj_queue <- rlang::enexprs(...) |> as.character();
self[[db]] %$% {
.tables <- sys.tables[sys.schemas, on = "schema_id"][!is.na(tbl_name)] %$% {
rlang::set_names(purrr::map2(dplyr::sql(schema_name), dplyr::sql(tbl_name), dbplyr::in_schema), tbl_name)
}
.views <- sys.views[sys.schemas, on = "schema_id"][!is.na(view_name)] %$% {
rlang::set_names(purrr::map2(dplyr::sql(schema_name), dplyr::sql(view_name), dbplyr::in_schema), view_name)
}
all_objs <- c(.tables, .view);
obj_queue <- unique(intersect(obj_queue) %||% all_objs);
} %>%
.[!duplicated(names(.))] |>
purrr::purrr::map(purrr::possibly(~dplyr::tbl(src = self$conns[[db]], from = .x), otherwise = "Could not connect")) |>
list2env(envir = db_env)
}
function(conn_name = names(self$conns), db_env = new.env(), ...){
db <- match.arg(conn_name);
obj_queue <- rlang::enexprs(...) |> as.character();
self[[db]] %$% {
.tables <- sys.tables[sys.schemas, on = "schema_id"][!is.na(tbl_name)] %$% {
rlang::set_names(purrr::map2(dplyr::sql(schema_name), dplyr::sql(tbl_name), dbplyr::in_schema), tbl_name)
}
.views <- sys.views[sys.schemas, on = "schema_id"][!is.na(view_name)] %$% {
rlang::set_names(purrr::map2(dplyr::sql(schema_name), dplyr::sql(view_name), dbplyr::in_schema), view_name)
}
all_objs <- c(.tables, .view);
obj_queue <- unique(intersect(obj_queue) %||% all_objs);
} %>%
.[!duplicated(names(.))] |>
purrr::map(purrr::possibly(~dplyr::tbl(src = self$conns[[db]], from = .x), otherwise = "Could not connect")) |>
list2env(envir = db_env)
}
source("~/ImperialGit/DBOE/R/DBOE.R", echo=TRUE)
library(DBOE)
(function(...){ rlang::enexprs(..., .named = TRUE) |> as.character() |> intersect(c("test", "this")) })(test, that)
(function(...){ rlang::enexprs(..., .named = TRUE) |> intersect(c("test", "this")) })(test, that)
(function(...){ rlang::enexprs(..., .named = TRUE) |> print()})(test, that)
(function(...){ rlang::enexprs(..., .named = TRUE) |> intersect(c(test = "test", this = "this")) })(test, that)
(function(...){ rlang::enexprs(..., .named = TRUE) |> purrr::keep(~.x intersect(.x, c("test", "this"))) })(test, that)
(function(...){ rlang::enexprs(..., .named = TRUE) |> purrr::keep(~.x, intersect(.x, c("test", "this"))) })(test, that)
(function(...){ rlang::enexprs(..., .named = TRUE) |> purrr::keep(~.x, .x %in% c("test", "this")) })(test, that)
(function(...){ rlang::enexprs(..., .named = TRUE) |> purrr::keep(~.x %in% c("test", "this")) })(test, that)
(function(...){ rlang::enexprs(..., .named = TRUE) %>% purrr::set_names(as.character(.)) })(test, this, that)
(function(...){ rlang::enexprs(..., .named = TRUE) |> magrittr::pipe_lazy_masking(purrr::set_names(as.character(.))) })(test, this, that)
(function(...){ rlang::enexprs(..., .named = TRUE) |> magrittr::pipe_lazy_masking(purrr::set_names(as.character(.))) |> intersect(c("this", "that")) })(test, this, that)
(function(...){ rlang::enexprs(..., .named = TRUE) |> magrittr::pipe_lazy_masking(purrr::set_names(as.character(.))) |> keep(~.x %in% c("this", "that")) })(test, this, that)
(function(...){ rlang::enexprs(..., .named = TRUE) |> magrittr::pipe_lazy_masking(purrr::set_names(as.character(.))) |> purrr::keep(~.x %in% c("this", "that")) })(test, this, that)
(function(...){ library(magrittr, include.only = "%>%"); rlang::enexprs(..., .named = TRUE) %>% purrr::set_names(as.character(.))) |> purrr::keep(~.x %in% c("this", "that")) })(test, this, that)
(function(...){ library(magrittr, include.only = "%>%"); rlang::enexprs(..., .named = TRUE) %>% purrr::set_names(as.character(.)) |> purrr::keep(~.x %in% c("this", "that")) })(test, this, that)
(function(...){ library(magrittr, include.only = "%>%"); rlang::enexprs(..., .named = TRUE) %>% purrr::set_names(as.character(unlist(.))) |> purrr::keep(~.x %in% c("this", "that")) })(test, this, that)
(function(...){ library(magrittr, include.only = "%>%"); rlang::enexprs(..., .named = TRUE) %>% purrr::set_names(as.character(unlist(.))) |> purrr::keep(~unlist(.x) %in% c("this", "that")) })(test, this, that)
(function(...){ library(magrittr, include.only = "%>%"); rlang::enexprs(..., .named = TRUE) %>% purrr::set_names(as.character(unlist(.)))  })(test, this, that)
(function(...){ library(magrittr, include.only = "%>%"); rlang::enexprs(..., .named = TRUE) %>% purrr::set_names(as.character(unlist(.)))  })(test, this, that) %in% c("test")
(function(...){ library(magrittr, include.only = "%>%"); rlang::enexprs(..., .named = TRUE) %>% purrr::set_names(as.character(unlist(.)))  })(test, this, that) %in% c("test", "this", "that")
(function(...){ library(magrittr, include.only = "%>%"); rlang::enexprs(..., .named = TRUE) %>% purrr::set_names(as.character(unlist(.)))  })(test, this, that) %>% .[. %in% c("test", "this", "that")]
(function(...){ library(magrittr, include.only = "%>%"); rlang::enexprs(..., .named = TRUE) %>% purrr::set_names(as.character(unlist(.)))  })(test, this, that) %>% .[. %in% c("test", "this")]
library(DBOE)
