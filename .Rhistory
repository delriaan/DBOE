][
, c("object_id", "database", "col_meta") := {
list(NULL, this.db, apply(
X = data.table(system_type_id, max_length, precision, scale, is_nullable
, is_identity, is_computed, is_xml_document)
, MARGIN = 1
, FUN = list
, simplify = FALSE
))
}
][
!is.na(tbl_name)
, !c("system_type_id", "max_length", "precision", "scale"
, "is_nullable", "is_identity", "is_computed", "is_xml_document")
]
} %>%
.[!duplicated(.[, !"col_meta"])] |>
data.table::setcolorder(c("database", "tbl_name", "col_name")) |>
data.table::setkey(tbl_name, column_id)
}
, MySQL = proxy_env %$% {
metamap <- { columns[
, .(database = this.db
, column_type
, ordinal_position
, col_meta = .SD[, .(
character_maximum_length
, character_octet_length
, precision = numeric_precision
, scale = numeric_scale
, column_default
, is_nullable
, extra
, privileges
, column_comment
, generation_expression
)] |>
purrr::array_branch(1)
), by = .(table_schema, tbl_name = col_name, col_name = column_name)
][
tables[, .(database = this.db, table_schema, tbl_name, table_type, max_data_length, table_comment)] |> unique()
, on = c("database", "table_schema", "tbl_name")
, nomatch = 0
, allow.cartesian = TRUE
]
}
metamap %<>% { .[!duplicated(.[, !"col_meta"])] |>
data.table::setnames("table_schema", "schema_name") |>
data.table::setkey(database, tbl_name, col_name) |>
data.table::setcolorder()
}
}
);
.meta_idx <- c(grepl("microsoft|odbcconnection", this.dbms, ignore.case = TRUE)
, grepl("mysql", this.db, ignore.case = TRUE)) |> which();
rlang::eval_tidy(metamap_action[[.meta_idx]]);
# Active bindings (VALIDATE: MySQL[1] MSSQL[1]) ====
message("Creating active bindings")
# Stored procedures (VALIDATE: MySQL[1] MSSQL[1])
if ((nrow(proxy_env$sys.procedures) %||% 0) > 0){
.temp <- proxy_env$sys.procedures[
!is.na(proc_name)
, list(list(.SD[, schema_name:proc_def]))
, by = proc_name
] %$% rlang::set_names(V1, proc_name);
proxy_env$.proc_dm <- rlang::as_data_mask(.temp);
ls(.temp, pattern = "^[a-z]") |> purrr::walk(~{
rlang::expr(makeActiveBinding(
sym = !!.x
, fun = function(){ rlang::eval_tidy(quo(.data[[!!.x]]), data = !!(proxy_env$.proc_dm)) }
, env = proxy_env
)) |> eval()
});
}
if ((nrow(proxy_env$routines) %||% 0) > 0){
.temp <- proxy_env$routines[
!is.na(proc_name)
, list(proc_created = created
, list(.SD[, .(proc_def, routine_comment)])
)
, by = .(proc_name, schema_name = routine_schema)
] %$% rlang::set_names(V2, proc_name);
proxy_env$.proc_dm <- rlang::as_data_mask(.temp)
ls(.temp, pattern = "^[a-z]") |> purrr::walk(~{
rlang::expr(makeActiveBinding(
sym = !!.x
, fun = function(){ rlang::eval_tidy(quo(.data[[!!.x]]), data = !!(proxy_env$.proc_dm)) }
, env = proxy_env
)) |> eval()
})
}
# Views (VALIDATE: MySQL[1] MSSQL[1])
if ((nrow(proxy_env$sys.views) %||% 0) > 0){
.temp <- proxy_env$sys.views[
!is.na(view_name)
, list(list(.SD[, schema_name:view_def]))
, by = view_name
] %$% rlang::set_names(V1, view_name);
proxy_env$.view_dm <- rlang::as_data_mask(.temp);
ls(.temp, pattern = "^[a-z]") |> purrr::walk(~{
rlang::expr(makeActiveBinding(
sym = !!.x
, fun = function(){ rlang::eval_tidy(quo(.data[[!!.x]]), data = !!(proxy_env$.view_dm)) }
, env = proxy_env
)) |> eval()
});
}
if ((nrow(proxy_env$views) %||% 0) > 0){
.temp <- proxy_env$views[!is.na(table_schema), .(view_name, schema_name = table_schema, view_def)];
proxy_env$.view_dm <- rlang::as_data_mask(.temp);
ls(.temp, pattern = "^[a-z]") |> purrr::walk(~{
rlang::expr(makeActiveBinding(
sym = !!.x
, fun = function(){ rlang::eval_tidy(quo(.data[[!!.x]]), data = !!(proxy_env$.view_dm)) }
, env = proxy_env
)) |> eval()
});
}
# Tables and Columns (VALIDATE: MySQL[1] MSSQL[1])
.temp <- proxy_env$metamap[!is.na(tbl_name)] |>
split(by = "tbl_name") |>
purrr::map(~{
split(.x, by = "col_name") |>
purrr::map(~.x[, schema_name:col_meta])
});
proxy_env$.tbl_dm <- rlang::as_data_mask(.temp);
ls(.temp, pattern = "^[a-zA-Z]") |> purrr::walk(~{
rlang::expr(makeActiveBinding(
sym = !!.x
, fun = function(){ rlang::eval_tidy(rlang::quo(.data[[!!.x]]), data = !!(proxy_env$.tbl_dm)) }
, env = proxy_env
)) |> eval()
});
tictoc::toc(log = TRUE, quiet = !chatty);
});
invisible(self);
},
#' @description
#' \code{$make.virtual_database} creates a set of \code{\link[dplyr]{tbl}} objects in an environment
#' @param conn The name of a metadata environment (created after calling \code{$get.metadata() })
#' @param target_ The environment object where created objects should be stored
#' @param ... Names of objects to retrieve.  If given as named arguments, the name becomes the local object name.
#' @return An assignable environment object with \code{DBI}-sourced \code{\link[dplyr]{tbl}}s
make.virtual_database = function(conn, target_env = rlang::caller_env(), ...){
force(target_env);
db <- purrr::modify_if(conn, is.numeric, ~names(private$connections)[.x]);
db_env <- self[[db]];
obj_queue <- rlang::enexprs(..., .named = TRUE) |>
purrr::map(rlang::as_label) |>
unlist() |>
paste(collapse = "|");
if (rlang::is_empty(obj_queue)){ return("No values passed to `...`: exiting ...") }
.tables <- ls(db_env, pattern = "^(sys.)?tables$");
.tables <- if (!rlang::is_empty(.tables)){
db_env[[.tables]] %look.for% obj_queue
}
.views <- ls(db_env, pattern = "^(sys.)?views$");
.views <- if (!rlang::is_empty(.views)){
db_env[[.views]] %look.for% obj_queue
}
obj_queue[obj_queue %in% all_objs] |>
purrr::discard(duplicated) |>
purrr::iwalk(purrr::possibly(~{
assign(.y, dplyr::tbl(src = private$connections[[db]], from = .x), envir = target_env)
}, otherwise = "Could not connect"));
invisible(self)
}
)}
, active = { list(
#' @field connection.list Sets or returns a list of saved connections
connection.list = function(i = NULL){
if (is.list(i)){ private$connections <- i } else { return(private$connections) }
}
)}
, private = { list(connections = NULL)}
)}
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items)
# load_unloaded(DBOE)
source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items)
X$mysql$tables
X$GW2DB$tables
X$GW2DB$sys.tables
X$GW2DB$sys.tables %look.for% "character"
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items)
# load_unloaded(DBOE)
source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items)
# load_unloaded(DBOE)
source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items)
# load_unloaded(DBOE)
source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items)
# load_unloaded(DBOE)
source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items)
X$make.virtual_database(conn = "mysql", target_env = globalenv(), rental)
#
`%look.for%` <- function(i, x){
#' Look for a Database Metadata
#'
#' The \code{\%look.for\%} operator searches the provided metadata environment or \code{metamap} object in such an environment for the pattern passed to \code{x}
#' @param i (object) A data.frame, data.table, or coercible containing object names
#' @param x (string[]) A vector of REGEX patterns or exact names to use for matching against database object names
#'
#' @return A \code{\link[data.table]{data.table}} object with the items that were found, if any
#'
#' @export
if (is.environment(i)){ if (rlang::env_has(i, "metamap")){ i <- i$metamap }}
if (!is.data.table(i)){ i <- as.data.table(i) }
.hits = i[, purrr::map(.SD, ~{
.needle = .x;
.haystack = x;
test_1 = which(.needle %in% .haystack)
test_2 = sapply(.haystack, function(.straw){ .needle %ilike% .straw }) |> which()
unlist(c(test_1, test_2)) |> unique()
}) |> unlist(use.names = FALSE)];
# Verify that results exists, or exit if not
if (identical(integer(0), .hits)){
message("[FAIL]: <" %s+% paste(x, collapse = ", ") %s+% "> not found or failed to find matches.");
return(0);
}
.out <- i[(.hits)] %>%
data.table::setattr(
"group_cols"
, intersect(c("database"
, "table_schema", "schema_name"
, "tbl_name", "proc_name", "view_name"
), names(i))
)
if ("col_names" %in% names(.out)){
.out[!is.na(col_name), .(col_names = list(c(col_name))), by = c(attr(.out, "group_cols"))]
} else { .out[, c(attr(.out, "group_cols")), with = FALSE] }
}
X$make.virtual_database(conn = "mysql", target_env = globalenv(), rental)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items)
X$make.virtual_database(conn = "mysql", target_env = globalenv(), rental)
source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items)
X$make.virtual_database(conn = "mysql", target_env = globalenv(), rental)
source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items)
X$make.virtual_database(conn = "mysql", target_env = globalenv(), rental)
source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items)
source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items)
X$make.virtual_database(conn = "mysql", target_env = globalenv(), rental)
source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items)
source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items)
source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items)
X$make.virtual_database(conn = "mysql", target_env = globalenv(), rental)
source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items)
X$make.virtual_database(conn = "mysql", target_env = globalenv(), rental)
dim_items
dim_items |> dbplyr::collect()
dim_items |> dplyr::collect()
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items, character)
X$make.virtual_database(conn = "mysql", target_env = globalenv(), rental, staff)
X$make.virtual_database(conn = "mysql", target_env = globalenv(), rental, staff)
library(book.of.workflow);
load_unloaded(purrr
, stringi
, magrittr
, rlang
, DBI
, httr
, keyring
, tictoc
, "data.table{+%like%}"
)
db_conns <- list()
db_conns$mysql <- DBI::dbConnect(odbc::odbc(), "MySQL"
, database = "mysql"
, user = "delriaan"
, password = keyring::key_get(service = "MySQL", username = "delriaan", keyring = "R"))
db_conns$GW2DB <- DBI::dbConnect(RODBCDBI::ODBC(), "GW2DB"
# , server = "imperialtower"
# , database = "GW2DB"
# , case = "nochange"
# , database = "GW2DB"
, user = "imperial_agent"
, password = keyring::key_get(service = "MSSQL", username = "imperial_agent", keyring = "R"))
source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items)
X$make.virtual_database(conn = "mysql", target_env = globalenv(), rental, staff)
source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items, character)
X$make.virtual_database(conn = "mysql", target_env = globalenv(), rental, staff)
library(DBOE)
library(DBOE)
db_conns <- list()
db_conns$mysql <- DBI::dbConnect(odbc::odbc(), "MySQL"
, database = "mysql"
, user = "delriaan"
, password = keyring::key_get(service = "MySQL", username = "delriaan", keyring = "R"))
db_conns$GW2DB <- DBI::dbConnect(RODBCDBI::ODBC(), "GW2DB"
# , server = "imperialtower"
# , database = "GW2DB"
# , case = "nochange"
# , database = "GW2DB"
, user = "imperial_agent"
, password = keyring::key_get(service = "MSSQL", username = "imperial_agent", keyring = "R"))
# source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
library(DBOE)
library(DBOE)
db_conns <- list()
db_conns$mysql <- DBI::dbConnect(odbc::odbc(), "MySQL"
, database = "mysql"
, user = "delriaan"
, password = keyring::key_get(service = "MySQL", username = "delriaan", keyring = "R"))
db_conns$GW2DB <- DBI::dbConnect(RODBCDBI::ODBC(), "GW2DB"
# , server = "imperialtower"
# , database = "GW2DB"
# , case = "nochange"
# , database = "GW2DB"
, user = "imperial_agent"
, password = keyring::key_get(service = "MSSQL", username = "imperial_agent", keyring = "R"))
# source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items, character)
X$make.virtual_database(conn = "mysql", target_env = globalenv(), rental, staff)
purrr::walk(db_conns, dbDisconnect)
rm(db_conns)
# ---------------
pkgdown::build_site(pkg = "pkg", override = "../docs")
getwd()
detach("package:DBOE", unload = TRUE)
# ---------------
pkgdown::build_site(pkg = "pkg", override = "../docs")
# ---------------
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
# ---------------
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
# ---------------
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
library(DBOE)
library(book.of.workflow);
# ---------------
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
library(DBOE)
# ---------------
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
library(DBOE)
# ---------------
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
purrr::walk(db_conns, dbDisconnect)
rm(db_conns)
db_conns <- list(
mysql = DBI::dbConnect(odbc::odbc(), "MySQL"
, database = "mysql"
, user = "delriaan"
, password = keyring::key_get(service = "MySQL", username = "delriaan", keyring = "R"))
, GW2DB = DBI::dbConnect(RODBCDBI::ODBC(), "GW2DB"
# , server = "imperialtower"
# , database = "GW2DB"
# , case = "nochange"
# , database = "GW2DB"
, user = "imperial_agent"
, password = keyring::key_get(service = "MSSQL", username = "imperial_agent", keyring = "R"))
)
# source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items, character)
X$make.virtual_database(conn = "mysql", target_env = globalenv(), rental, staff)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items, character, jobs = profession)
library(DBOE)
db_conns <- list(
mysql = DBI::dbConnect(odbc::odbc(), "MySQL"
, database = "mysql"
, user = "delriaan"
, password = keyring::key_get(service = "MySQL", username = "delriaan", keyring = "R"))
, GW2DB = DBI::dbConnect(RODBCDBI::ODBC(), "GW2DB"
# , server = "imperialtower"
# , database = "GW2DB"
# , case = "nochange"
# , database = "GW2DB"
, user = "imperial_agent"
, password = keyring::key_get(service = "MSSQL", username = "imperial_agent", keyring = "R"))
)
# source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items, character, jobs = profession)
X$make.virtual_database(conn = "mysql", target_env = globalenv(), rental, staff)
purrr::walk(db_conns, dbDisconnect)
rm(db_conns)
# PKGDOWN ----
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
# load_unloaded(purrr
# 	, stringi
# 	, magrittr
# 	, rlang
# 	, DBI
# 	, httr
# 	, keyring
# 	, tictoc
# 	, "data.table{+%like%}"
# 	)
library(DBOE)
db_conns <- list(
mysql = DBI::dbConnect(odbc::odbc(), "MySQL"
, database = "mysql"
, user = "delriaan"
, password = keyring::key_get(service = "MySQL", username = "delriaan", keyring = "R"))
, GW2DB = DBI::dbConnect(RODBCDBI::ODBC(), "GW2DB"
# , server = "imperialtower"
# , database = "GW2DB"
# , case = "nochange"
# , database = "GW2DB"
, user = "imperial_agent"
, password = keyring::key_get(service = "MSSQL", username = "imperial_agent", keyring = "R"))
)
# source("pkg/R/DBOE.R")
X <- DBOE$new()
# debug(X$get.metadata)
X$get.metadata(!!!db_conns)
# undebug(X$make.virtual_database)
X$make.virtual_database(conn = "GW2DB", target_env = globalenv(), dim_items, character, jobs = profession)
X$make.virtual_database(conn = "mysql", target_env = globalenv(), rental, staff)
purrr::walk(db_conns, dbDisconnect)
rm(db_conns)
